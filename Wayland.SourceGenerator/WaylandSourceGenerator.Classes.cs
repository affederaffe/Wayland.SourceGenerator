namespace Wayland.SourceGenerator
{
    public partial class WaylandSourceGenerator
    {
        public const string WaylandExceptionClass = "public class WaylandException(string message) : Exception(message);";

        public const string LibWaylandClass = """
                                              // <auto-generated/>
                                              using System;
                                              using System.Runtime.InteropServices;


                                              #pragma warning disable
                                              #nullable enable
                                              namespace Wayland.SourceGenerator
                                              {
                                                  internal static unsafe class LibWayland
                                                  {
                                                      private const string Wayland = "libwayland-client.so.0";

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true, CharSet = CharSet.Unicode)]
                                                      internal static extern IntPtr wl_display_connect(string? name);
                                                      
                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_create_queue(IntPtr display);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_get_fd(IntPtr display);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_dispatch(IntPtr display);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_dispatch_queue(IntPtr display, IntPtr queue);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_dispatch_pending(IntPtr display);
                                                      
                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_dispatch_queue_pending(IntPtr display, IntPtr queue);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_roundtrip(IntPtr display);
                                                      
                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_roundtrip_queue(IntPtr display, IntPtr queue);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_prepare_read(IntPtr display);
                                                      
                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_prepare_read_queue(IntPtr display, IntPtr queue);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_read_events(IntPtr display);

                                                      [DllImport(Wayland, SetLastError = true, ExactSpelling = true)]
                                                      internal static extern int wl_display_flush(IntPtr display);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern void wl_display_cancel_read(IntPtr display);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern void wl_display_disconnect(IntPtr display);
                                                      
                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern void wl_event_queue_destroy(IntPtr queue);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern void wl_proxy_marshal_array(IntPtr proxy, uint opcode, WlArgument* args);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern IntPtr wl_proxy_marshal_array_constructor_versioned(IntPtr proxy, uint opcode, WlArgument* args, ref WlInterface @interface, uint version);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern IntPtr wl_proxy_create_wrapper(IntPtr proxy);
                                                      
                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern IntPtr wl_proxy_set_queue(IntPtr proxy, IntPtr queue);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      private static extern int wl_proxy_add_dispatcher(IntPtr proxy, delegate*<void*, void*, uint, WlMessage*, WlArgument*, int> dispatcherFunc, void* implementation, void* data);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      private static extern uint wl_proxy_get_id(IntPtr proxy);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern void wl_proxy_destroy(IntPtr proxy);

                                                      [DllImport(Wayland, ExactSpelling = true)]
                                                      internal static extern void wl_proxy_wrapper_destroy(IntPtr proxyWrapper);

                                                      private static readonly Dictionary<uint, WeakReference<WlProxy>> _proxies = new();

                                                      private static int WlProxyDispatcher(void* implementation, void* target, uint opcode, WlMessage* message, WlArgument* arguments)
                                                      {
                                                          uint id = (uint)implementation;
                                                          WlProxy? proxy;
                                                          lock (_proxies)
                                                          {
                                                              if (!_proxies.TryGetValue(id, out WeakReference<WlProxy>? weakRef))
                                                                  return 0;

                                                              if (!weakRef.TryGetTarget(out proxy))
                                                              {
                                                                  _proxies.Remove(id);
                                                                  return 0;
                                                              }
                                                          }

                                                          proxy.DispatchEvent(opcode, message, arguments);
                                                          return 0;
                                                      }

                                                      public static uint RegisterProxy(WlProxy wlProxy)
                                                      {
                                                          lock (_proxies)
                                                          {
                                                              uint id = wl_proxy_get_id(wlProxy.Handle);
                                                              void* idp = (void*)id;
                                                              int ret = wl_proxy_add_dispatcher(wlProxy.Handle, &WlProxyDispatcher, idp, idp);
                                                              if (ret == -1)
                                                                  throw new WaylandException($"Failed to add dispatcher for proxy of type {wlProxy.GetType().Name}");
                                                              _proxies[id] = new WeakReference<WlProxy>(wlProxy);
                                                              return id;
                                                          }
                                                      }

                                                      public static void UnregisterProxy(uint id)
                                                      {
                                                          lock (_proxies)
                                                              _proxies.Remove(id);
                                                      }

                                                      public static WlProxy? FindByNative(IntPtr proxy)
                                                      {
                                                          lock (_proxies)
                                                          {
                                                              uint id = wl_proxy_get_id(proxy);
                                                              if (!_proxies.TryGetValue(id, out WeakReference<WlProxy>? weakRef))
                                                              {
                                                                  // TODO: Investigate
                                                                  // It's unclear if we should create a new managed object for wl_proxy here
                                                                  // since it means that said proxy was created by the native code
                                                                  return null;
                                                              }

                                                              if (!weakRef.TryGetTarget(out WlProxy? target))
                                                                  _proxies.Remove(id);
                                                              return target;
                                                          }
                                                      }
                                                  }
                                              }
                                              """;

        public const string BindFactoryInterface = """
                                                   // <auto-generated/>
                                                   using System;


                                                   #pragma warning disable
                                                   #nullable enable
                                                   namespace Wayland.SourceGenerator
                                                   {
                                                       internal unsafe interface IBindFactory<out T>
                                                       {
                                                           WlInterface* GetInterface();

                                                           T Create(IntPtr handle, int version);
                                                       }
                                                   }
                                                   """;

        public const string WlProxyClass = """
                                           // <auto-generated/>
                                           using System;
                                           using System.Collections.Generic;
                                           using Wayland.SourceGenerator;


                                           #pragma warning disable
                                           #nullable enable
                                           namespace Wayland.SourceGenerator
                                           {
                                               internal abstract unsafe class WlProxy
                                               {
                                                   private readonly uint _id;

                                                   private bool _isDestroyed;

                                                   protected WlProxy(IntPtr handle, int version)
                                                   {
                                                       Version = version;
                                                       Handle = handle;
                                                       _id = LibWayland.RegisterProxy(this);
                                                   }

                                                   internal int Version { get; }

                                                   internal IntPtr Handle { get; }

                                                   protected abstract WlInterface* GetWlInterface();

                                                   protected abstract void DispatchEvent(uint opcode, WlArgument* arguments);

                                                   internal void DispatchEvent(uint opcode, WlMessage* message, WlArgument* arguments)
                                                   {
                                                       // Sanity checks
                                                       // TODO: trigger a warning or something if this happens for some weird reason
                                                       WlInterface* @interface = GetWlInterface();
                                                       if (opcode >= @interface->EventCount)
                                                           return;
                                                       WlMessage protocolMsg = @interface->Events[opcode];
                                                       if(!strcmp(protocolMsg.Name, message->Name))
                                                           return;
                                                       if(!strcmp(protocolMsg.Signature, message->Signature))
                                                           return;
                                                       DispatchEvent(opcode, arguments);
                                                   }

                                                   protected internal void DestroyProxy()
                                                   {
                                                       if (_isDestroyed)
                                                           throw new WaylandException("This proxy has already been destroyed.");
                                                       LibWayland.UnregisterProxy(_id);
                                                       LibWayland.wl_proxy_destroy(Handle);
                                                       _isDestroyed = true;
                                                   }

                                                   protected static T? FromNative<T>(IntPtr proxy) where T : WlProxy => proxy == IntPtr.Zero ? null : LibWayland.FindByNative(proxy) as T;

                                                   private static bool strcmp(byte* left, byte* right)
                                                   {
                                                       for (int c = 0;; c++)
                                                       {
                                                           if (left[c] != right[c])
                                                               return false;
                                                           if (left[c] == 0)
                                                               return true;
                                                       }
                                                   }
                                               }
                                           }
                                           """;

        public const string WlProxyWrapperClass = """
                                                  // <auto-generated/>
                                                  using Wayland.SourceGenerator;


                                                  #pragma warning disable
                                                  #nullable enable
                                                  namespace Wayland.SourceGenerator
                                                  {
                                                      internal class WlProxyWrapper<T> where T : WlProxy
                                                      {
                                                          public WlProxyWrapper(IBindFactory<T> factory, T proxy)
                                                          {
                                                              Wrapper = factory.Create(proxy.Handle, proxy.Version);
                                                          }

                                                          public T? Wrapper { get; private set; }

                                                          public void SetQueue(WlEventQueue queue)
                                                          {
                                                              LibWayland.wl_proxy_set_queue(Wrapper.Handle, queue.Handle);
                                                          }

                                                          public void Destroy()
                                                          {
                                                              if (Wrapper is null)
                                                                  throw new WaylandException("Cannot destroy a proxy that is already destroyed.");
                                                              LibWayland.wl_proxy_wrapper_destroy(Wrapper.Handle);
                                                              Wrapper = null;
                                                          }
                                                      }
                                                  }
                                                  """;

        public const string WlDisplayClass = """
                                             // <auto-generated/>
                                             using Wayland.SourceGenerator;


                                             #pragma warning disable
                                             #nullable enable
                                             namespace Wayland
                                             {
                                                 internal partial class WlDisplay
                                                 {
                                                     public static WlDisplay Connect(string? name = null)
                                                     {
                                                         var handle = LibWayland.wl_display_connect(name);
                                                         if (handle == IntPtr.Zero)
                                                             throw new WaylandException("Failed to connect to wayland display.");
                                                         return new WlDisplay(handle, WlInterface.Version);
                                                     }

                                                     private bool _isDisconnected;

                                                     public int GetFd() => LibWayland.wl_display_get_fd(Handle);

                                                     public int Dispatch() => LibWayland.wl_display_dispatch(Handle);

                                                     public int DispatchQueue(WlEventQueue queue) => LibWayland.wl_display_dispatch_queue(Handle, queue.Handle);

                                                     public int DispatchPending() => LibWayland.wl_display_dispatch_pending(Handle);

                                                     public int DispatchQueuePending(WlEventQueue queue) => LibWayland.wl_display_dispatch_queue_pending(Handle, queue.Handle);

                                                     public int Roundtrip() => LibWayland.wl_display_roundtrip(Handle);
                                                     
                                                     public int RoundtripQueue(WlEventQueue queue) => LibWayland.wl_display_roundtrip_queue(Handle, queue.Handle);

                                                     public int PrepareRead() => LibWayland.wl_display_prepare_read(Handle);

                                                     public int PrepareReadQueue(WlEventQueue queue) => LibWayland.wl_display_prepare_read_queue(Handle, queue.Handle);

                                                     public int ReadEvents() => LibWayland.wl_display_read_events(Handle);

                                                     public int Flush() => LibWayland.wl_display_flush(Handle);

                                                     public void CancelRead() => LibWayland.wl_display_cancel_read(Handle);

                                                     public WlEventQueue CreateQueue() => new WlEventQueue(LibWayland.wl_display_create_queue(Handle));

                                                     public void Disconnect()
                                                     {
                                                         if (_isDisconnected)
                                                             throw new WaylandException("Display is already disconnected.");
                                                          LibWayland.wl_display_disconnect(Handle);
                                                          _isDisconnected = true;
                                                     }
                                                 }
                                             }
                                             """;

        public const string WlEventQueueClass = """
                                                // <auto-generated/>
                                                using Wayland.SourceGenerator;


                                                #pragma warning disable
                                                #nullable enable
                                                namespace Wayland
                                                {
                                                    internal class WlEventQueue
                                                    {
                                                        internal WlEventQueue(IntPtr handle)
                                                        {
                                                            Handle = handle;
                                                        }

                                                        public IntPtr Handle { get; private set; }

                                                        public void Destroy()
                                                        {
                                                            if (Handle == IntPtr.Zero)
                                                                throw new WaylandException("Queue is already destroyed.");
                                                            LibWayland.wl_event_queue_destroy(Handle);
                                                            Handle = IntPtr.Zero;
                                                        }
                                                    }
                                                }
                                                """;

        public const string WlRegistryClass = """
                                              // <auto-generated/>
                                              using System.Runtime.InteropServices;
                                              using Wayland.SourceGenerator;


                                              #pragma warning disable
                                              #nullable enable
                                              namespace Wayland
                                              {
                                                  internal unsafe partial class WlRegistry
                                                  {
                                                      public T? Bind<T>(uint name, IBindFactory<T> factory, int version) where T : WlProxy
                                                      {
                                                          ref WlInterface wlInterface = ref *factory.GetInterface();
                                                          if (wlInterface.Version < version)
                                                              throw new ArgumentException($"Requested version {version} of {Marshal.PtrToStringAnsi(wlInterface.Name)} is not supported by the protocol version used to generate bindings. Bindings were generated for version {wlInterface.Version}");

                                                          WlArgument* args = stackalloc WlArgument[]
                                                          {
                                                              name,
                                                              wlInterface.Name,
                                                              version,
                                                              WlArgument.NewId
                                                          };

                                                          IntPtr proxy = LibWayland.wl_proxy_marshal_array_constructor_versioned(Handle, 0, args, ref wlInterface, (uint)wlInterface.Version);
                                                          return proxy == IntPtr.Zero ? null : factory.Create(proxy, version);
                                                      }
                                                  }
                                              }
                                              """;

        public const string Utf8BufferClass = """
                                              // <auto-generated/>
                                              using System;
                                              using System.Buffers;
                                              using System.Collections.Generic;
                                              using System.Runtime.InteropServices;
                                              using System.Text;


                                              #pragma warning disable
                                              #nullable enable
                                              namespace Wayland.SourceGenerator
                                              {
                                                  internal class Utf8Buffer : SafeHandle
                                                  {
                                                      private GCHandle _gcHandle;
                                                      private byte[]? _data;

                                                      public Utf8Buffer(string? str) : base(IntPtr.Zero, true)
                                                      {
                                                          if (str is null)
                                                              return;
                                                          int len = Encoding.UTF8.GetByteCount(str);
                                                          _data = ArrayPool<byte>.Shared.Rent(len + 1);
                                                          Encoding.UTF8.GetBytes(str, 0, str.Length, _data, 0);
                                                          _data[len] = 0;
                                                          _gcHandle = GCHandle.Alloc(_data, GCHandleType.Pinned);
                                                          handle = _gcHandle.AddrOfPinnedObject();
                                                      }

                                                      public override bool IsInvalid => handle == IntPtr.Zero;

                                                      protected override bool ReleaseHandle()
                                                      {
                                                          if (handle == IntPtr.Zero)
                                                              return true;

                                                          if (_data is not null)
                                                              ArrayPool<byte>.Shared.Return(_data);

                                                          handle = IntPtr.Zero;
                                                          _data = null;
                                                          _gcHandle.Free();
                                                          return true;
                                                      }
                                                  }
                                              }
                                              """;

        public const string WlMessageStruct = """
                                              // <auto-generated/>
                                              using System;
                                              using System.Runtime.InteropServices;


                                              #pragma warning disable
                                              #nullable enable
                                              namespace Wayland.SourceGenerator
                                              {
                                                  [StructLayout(LayoutKind.Sequential)]
                                                  internal unsafe struct WlMessage
                                                  {
                                                      public readonly byte* Name;
                                                      public readonly byte* Signature;
                                                      public readonly WlInterface** Types;

                                                      public WlMessage(string name, string signature, WlInterface*[]? types)
                                                      {
                                                          types ??= OneNullType;
                                                          Types = (WlInterface**)Marshal.AllocHGlobal(IntPtr.Size * types.Length);
                                                          for (int i = 0; i < types.Length; i++)
                                                              Types[i] = types[i];
                                                          Name = (byte*)Marshal.StringToHGlobalAnsi(name);
                                                          Signature = (byte*)Marshal.StringToHGlobalAnsi(signature);
                                                      }

                                                      private static readonly WlInterface*[] OneNullType = [null];
                                                  }
                                              }
                                              """;

        public const string WlInterfaceStruct = """
                                                // <auto-generated/>
                                                using System;
                                                using System.Runtime.InteropServices;


                                                #pragma warning disable
                                                #nullable enable
                                                namespace Wayland.SourceGenerator
                                                {
                                                    [StructLayout(LayoutKind.Sequential)]
                                                    internal unsafe struct WlInterface
                                                    {
                                                        public readonly IntPtr Name;
                                                        public readonly int Version;
                                                        public readonly int MethodCount;
                                                        public readonly WlMessage* Methods;
                                                        public readonly int EventCount;
                                                        public readonly WlMessage* Events;

                                                        public WlInterface(string name, int version, WlMessage[]? methods, WlMessage[]? events)
                                                        {
                                                            Name = Marshal.StringToHGlobalAnsi(name);
                                                            Version = version;
                                                            MethodCount = methods?.Length ?? 0;
                                                            Methods = UnmanagedCopy(methods);
                                                            EventCount = events?.Length ?? 0;
                                                            Events = UnmanagedCopy(events);
                                                        }

                                                        public static WlInterface* GeneratorAddressOf(ref WlInterface s)
                                                        {
                                                            fixed (WlInterface* ptr = &s)
                                                                return ptr;
                                                        }

                                                        private static WlMessage* UnmanagedCopy(WlMessage[]? messages)
                                                        {
                                                            if (messages is null || messages.Length == 0)
                                                                return null;
                                                            WlMessage* ptr = (WlMessage*)Marshal.AllocHGlobal(sizeof(WlMessage) * messages.Length);
                                                            for (int c = 0; c < messages.Length; c++)
                                                                ptr[c] = messages[c];
                                                            return ptr;
                                                        }
                                                    }
                                                }
                                                """;

        public const string WlArgumentStruct = """
                                               // <auto-generated/>
                                               using System;
                                               using System.Runtime.InteropServices;


                                               #pragma warning disable
                                               #nullable enable
                                               namespace Wayland.SourceGenerator
                                               {
                                                   [StructLayout(LayoutKind.Explicit)]
                                                   internal unsafe struct WlArgument
                                                   {
                                                       [FieldOffset(0)]
                                                       public int Int32;

                                                       [FieldOffset(0)]
                                                       public uint UInt32;

                                                       [FieldOffset(0)]
                                                       public IntPtr IntPtr;

                                                       [FieldOffset(0)]
                                                       public WlFixed WlFixed;

                                                       public static implicit operator WlArgument(int value) => new() { Int32 = value };

                                                       public static implicit operator WlArgument(uint value) => new() { UInt32 = value };

                                                       public static implicit operator WlArgument(IntPtr value) => new() { IntPtr = value };

                                                       public static implicit operator WlArgument(WlArray* value) => new() { IntPtr = (IntPtr)value };

                                                       public static implicit operator WlArgument(WlFixed value) => new() { WlFixed = value };

                                                       public static implicit operator WlArgument(WlProxy? value) => new() { IntPtr = value?.Handle ?? IntPtr.Zero };

                                                       public static implicit operator WlArgument(SafeHandle? value) => new() { IntPtr = value?.DangerousGetHandle() ?? IntPtr.Zero };

                                                       public static readonly WlArgument NewId;
                                                   }
                                               }
                                               """;

        public const string WlArrayStruct = """
                                            // <auto-generated/>
                                            using System;
                                            using System.Runtime.InteropServices;


                                            #pragma warning disable
                                            #nullable enable
                                            namespace Wayland.SourceGenerator
                                            {
                                                [StructLayout(LayoutKind.Sequential)]
                                                internal readonly unsafe ref struct WlArray(nint size, nint alloc, void* data)
                                                {
                                                    public readonly nint Size = size;
                                                    public readonly nint Alloc = alloc;
                                                    public readonly void* Data = data;

                                                    public Span<T> AsSpan<T>() where T : unmanaged
                                                    {
                                                        int size = (int)(Size / sizeof(T));
                                                        return size == 0 ? Span<T>.Empty : new Span<T>(Data, size);
                                                    }

                                                    public static WlArray FromPointer<T>(T* ptr, int count) where T : unmanaged
                                                    {
                                                        nint size = sizeof(T) * count;
                                                        return new WlArray(size, size, ptr);
                                                    }

                                                    public static Span<T> SpanFromWlArrayPtr<T>(IntPtr ptr) where T : unmanaged => ptr == null ? Span<T>.Empty : ((WlArray*)ptr)->AsSpan<T>();
                                                }
                                            }
                                            """;

        public const string WlFixedStruct = """
                                            // <auto-generated/>
                                            using System;
                                            using System.Runtime.InteropServices;


                                            #pragma warning disable
                                            #nullable enable
                                            namespace Wayland.SourceGenerator
                                            {
                                                internal readonly struct WlFixed : IComparable<WlFixed>, IEquatable<WlFixed>
                                                {
                                                   private readonly int _value;

                                                   public WlFixed(int value)
                                                   {
                                                       _value = value * 256;
                                                   }

                                                   public WlFixed(double value)
                                                   {
                                                       Union u = new() { Double = value + (3L << (51 - 8)) };
                                                       _value = (int)u.Int64;
                                                   }

                                                   public static explicit operator int(WlFixed wlFixed) => wlFixed._value / 256;

                                                   public static explicit operator double(WlFixed wlFixed)
                                                   {
                                                       Union u = new() { Int64 = ((1023L + 44L) << 52) + (1L << 51) + wlFixed._value };
                                                       return u.Double - (3L << 43);
                                                   }

                                                   [StructLayout(LayoutKind.Explicit)]
                                                   private struct Union
                                                   {
                                                       [FieldOffset(0)]
                                                       public double Double;
                                            
                                                       [FieldOffset(0)]
                                                       public long Int64;
                                                   }

                                                   public int CompareTo(WlFixed other) => _value.CompareTo(other._value);

                                                   public bool Equals(WlFixed other) => _value == other._value;

                                                   public override bool Equals(object? obj) => obj is WlFixed other && Equals(other);

                                                   public override int GetHashCode() => _value;

                                                   public static bool operator ==(WlFixed left, WlFixed right) => left._value == right._value;

                                                   public static bool operator !=(WlFixed left, WlFixed right) => left._value != right._value;

                                                   public static bool operator <(WlFixed left, WlFixed right) => left._value < right._value;

                                                   public static bool operator <=(WlFixed left, WlFixed right) => left._value <= right._value;

                                                   public static bool operator >(WlFixed left, WlFixed right) => left._value > right._value;

                                                   public static bool operator >=(WlFixed left, WlFixed right) => left._value >= right._value;
                                                }
                                            }
                                            """;
    }
}
