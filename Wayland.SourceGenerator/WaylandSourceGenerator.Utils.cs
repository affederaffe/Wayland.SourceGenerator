using System;
using System.Collections.Frozen;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;


namespace Wayland.SourceGenerator
{
    public static partial class WaylandSourceGenerator
    {
        private static string Pascalize(ReadOnlySpan<char> name, bool camel = false)
        {
            bool upperizeNext = !camel;
            StringBuilder sb = new(name.Length);
            foreach (char och in name)
            {
                char ch = och;
                if (ch is '_' or '.')
                {
                    upperizeNext = true;
                }
                else
                {
                    if (upperizeNext)
                    {
                        ch = char.ToUpperInvariant(ch);
                        upperizeNext = false;
                    }

                    sb.Append(ch);
                }
            }

            return sb.ToString();
        }

        internal static CompilationUnitSyntax MakeCompilationUnit(NamespaceDeclarationSyntax namespaceDeclaration) =>
            CompilationUnit()
                .AddUsings(
                    UsingDirective(
                        IdentifierName("System")),
                    UsingDirective(
                        IdentifierName("System.Runtime.CompilerServices")),
                    UsingDirective(
                        IdentifierName("System.Runtime.InteropServices")),
                    UsingDirective(
                        IdentifierName("Wayland.SourceGenerator")))
                .WithLeadingTrivia(Comment("// <auto-generated>"))
                .AddMembers(namespaceDeclaration
                    .WithLeadingTrivia(
                        TriviaList(
                            Trivia(
                                PragmaWarningDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)),
                            Trivia(
                                NullableDirectiveTrivia(
                                    Token(SyntaxKind.EnableKeyword), true)))))
                .NormalizeWhitespace();

        private static LiteralExpressionSyntax MakeLiteralExpression(int value) => LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(value));

        private static LiteralExpressionSyntax MakeLiteralExpression(string value) => LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(value));

        private static LiteralExpressionSyntax MakeNullLiteralExpression() => LiteralExpression(SyntaxKind.NullLiteralExpression);

        private static PropertyDeclarationSyntax MakeGetSetProperty(TypeSyntax type, string identifier, params SyntaxToken[] modifiers) =>
            PropertyDeclaration(type, identifier)
                .AddModifiers(modifiers)
                .AddAccessorListAccessors(
                    AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                        .WithSemicolonToken(
                            Token(SyntaxKind.SemicolonToken)),
                    AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                        .WithSemicolonToken(
                            Token(SyntaxKind.SemicolonToken)));

        private static IfStatementSyntax MakeNullCheck(string argumentName) =>
            IfStatement(
                IsPatternExpression(
                    IdentifierName(argumentName),
                    ConstantPattern(MakeNullLiteralExpression())),
                ThrowStatement(
                    ObjectCreationExpression(
                            IdentifierName("ArgumentNullException"))
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(
                                        MakeLiteralExpression(argumentName)))))));

        private static T WithObsoleteAttribute<T>(this T member) where T : MemberDeclarationSyntax =>
            (T)member.WithAttributeLists(
                SingletonList(
                    AttributeList(
                        SingletonSeparatedList(
                            Attribute(
                                IdentifierName("Obsolete"))))));

        internal static SyntaxToken GetNamespaceName(WaylandProtocol wlProtocol)
        {
            ReadOnlySpan<char> name = wlProtocol.Name.AsSpan();
            int i = name.Length - 1;
            while (char.IsDigit(name[i]))
                i--;

            if (name.Length - i - 1 >= 0 && name[i] == 'v' && name[i - 1] == '_')
                name = name.Slice(0, i - 1);

            return Identifier(
                Pascalize(name));
        }

        internal static SyntaxToken GetClassTypeName(string wlInterfaceName) =>
            Identifier(
                Pascalize(wlInterfaceName.AsSpan()));

        private static SyntaxToken GetEnumTypeName(string wlEnumName) =>
            Identifier(
                $"{Pascalize(wlEnumName.AsSpan())}Enum");

        private static TypeSyntax GetQualifiedEnumType(string name, FrozenDictionary<string, WaylandProtocol> interfaceToProtocolDict)
        {
            string[] parts = name.Split('.');
            if (parts.Length == 1)
            {
                return IdentifierName(
                    GetEnumTypeName(parts[0]));
            }

            return QualifiedName(
                QualifiedName(
                    IdentifierName(
                        GetNamespaceName(
                            interfaceToProtocolDict[parts[0]])),
                    IdentifierName(
                        GetClassTypeName(parts[0]))),
                IdentifierName(
                    GetEnumTypeName(parts[1])));
        }

        private static QualifiedNameSyntax GetQualifiedClassType(string name, FrozenDictionary<string, WaylandProtocol> interfaceToProtocolDict) =>
            QualifiedName(
                IdentifierName(
                    GetNamespaceName(interfaceToProtocolDict[name])),
                IdentifierName(
                    GetClassTypeName(name)));

        private static string SanitizeIdentifier(string identifier)
        {
            if (char.IsDigit(identifier[0]))
                return $"D{identifier}";
            if (_keywords.Contains(identifier))
                return $"@{identifier}";
            return identifier;
        }

        private static InvocationExpressionSyntax GetWlInterfaceAddressFor(string wlInterfaceName, FrozenDictionary<string, WaylandProtocol> interfaceToProtocolDict)
            => InvocationExpression(
                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("WlInterface"), IdentifierName("GeneratorAddressOf")), ArgumentList(
                    SingletonSeparatedList(
                        Argument(
                            GetWlInterfaceRefFor(wlInterfaceName, interfaceToProtocolDict)))));

        private static RefExpressionSyntax GetWlInterfaceRefFor(string wlInterfaceName, FrozenDictionary<string, WaylandProtocol> interfaceToProtocolDict) =>
            RefExpression(
                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    GetQualifiedClassType(wlInterfaceName, interfaceToProtocolDict),
                    IdentifierName("WlInterface")));

        private static MemberAccessExpressionSyntax GetWlInterfaceVersionFor(string wlInterfaceName, FrozenDictionary<string, WaylandProtocol> interfaceToProtocolDict) =>
            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    GetQualifiedClassType(wlInterfaceName, interfaceToProtocolDict),
                    IdentifierName("WlInterface")), IdentifierName("Version"));

        private static readonly string[] _keywords =
        [
            "abstract",
            "as",
            "base",
            "bool",
            "break",
            "byte",
            "case",
            "catch",
            "char",
            "checked",
            "class",
            "const",
            "continue",
            "decimal",
            "default",
            "delegate",
            "do",
            "double",
            "else",
            "enum",
            "event",
            "explicit",
            "extern",
            "false",
            "finally",
            "fixed",
            "float",
            "for",
            "foreach",
            "goto",
            "if",
            "implicit",
            "in",
            "int",
            "interface",
            "internal",
            "is",
            "lock",
            "long",
            "namespace",
            "new",
            "null",
            "object",
            "operator",
            "out",
            "override",
            "params",
            "private",
            "protected",
            "public",
            "readonly",
            "ref",
            "return",
            "sbyte",
            "sealed",
            "short",
            "sizeof",
            "stackalloc",
            "static",
            "string",
            "struct",
            "switch",
            "this",
            "throw",
            "true",
            "try",
            "typeof",
            "uint",
            "ulong",
            "unchecked",
            "unsafe",
            "ushort",
            "using",
            "virtual",
            "void",
            "volatile",
            "while"
        ];
    }
}
